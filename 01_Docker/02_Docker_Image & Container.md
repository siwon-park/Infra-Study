![Docker image](https://user-images.githubusercontent.com/93081720/174341063-d8894c50-7452-49b0-ae2f-7a4b019dc8a9.png)

# 02_Docker_Image & Container

## 01_이미지와 컨테이너

### 컨테이너(Container)

> Unit of S/W



### 이미지(Image)

> 컨테이너의 설계도/템플릿 + 코드/필요 툴 및 환경 => 공유 가능한 패키지의 개념

**☆★ 컨테이너는 이미지의 구체적인 실행 인스턴스(이미지 기반의 컨테이너) ★☆**

build 명령어를 통해 이미지를 만들고, run 명령어를 통해 이미지의 인스턴스인 컨테이너를 만듦

(흔히 run <이미지명> 명령어를 보고 이미지를 실행한다고 착각하기 쉽지만, 실행하는 것은 이미지가 아니라 이미지를 기반으로 하는 컨테이너를 실행하는 것임)

※ 이미지에서 명시한 실행환경이 없더라도 도커 허브에서 해당 실행환경 이미지를 불러와서 이미지를 커스텀하는 것이 가능함

<br>

## 02_레이어 기반의 아키텍쳐

### 이미지의 특징

> Read Only

이미지는 '읽기 전용'이며, 일단 이미지가 한번 빌드된 후에는 소스코드를 변경하더라도 컨테이너 재시작 시 소스코드에 변경한 내용이 반영되지 않음 => 이미지를 리빌딩(re-building)해줘야 소스코드의 변경된 내용이 반영됨. 즉, 이미지는 한번 빌드하고 나면  빌드된 그 당시의 상태로 lock되는 snapshot의 개념

![image](https://user-images.githubusercontent.com/93081720/174914124-0f4df12a-4bc2-4362-92ce-9a714d18edea.png)

다수의 개별 컨테이너는 동일한 이미지를 기반으로 할 수 있지만 컨테이너 간에는 서로 완전히 독립적임

각 이미지 레이어들은 빌드(생성) 후 캐시(cache)되고, 도커는 현재의 실행이 이전과 동일하다고 판단되면 캐시를 사용함(동일 작업에 대해 속도를 최적화하기 위함). 대신 만약 어떤 이미지의 레이어가 변경되었으면, 그 후속 레이어도 전부 변경됐다고 가정하고 다시 빌드하며 이때 캐시를 사용하지 않음

<br>

### Dockerfile

이미지 빌드 파일에 명령어는 모두 대문자로 쓴다 

![image](https://user-images.githubusercontent.com/93081720/174643975-c731f4b2-aaf5-435e-81a1-19d87738600c.png)

- `FROM` : 다른 이미지 파일을 불러옴 import의 개념
  - FROM node : node.js에 대한 실행환경이 로컬에 있든 없든, 도커 허브에서 node.js 실행환경에 대한 이미지를 불러와서 커스텀하여 사용함
- `WORKDIR` : RUN명령어에 대한 작업 공간을 WORKDIR에 한정시킨다는 의미. 지정하지 않을 시 루트가 기본값임. 여기에 나와있는 /app은 실제 있는 폴더가 아니고 컨테이너 안에 존재하는 내부의 폴더임
- `COPY` : 어떤 파일이 이미지에 빌드되어야 하는지 지정(복사)함.
  - COPY . .에서 첫번째 . 은 현재 디렉토리, 두번째 . 은 해당 파일을 저장(복사)해야하는 이미지 내부의 경로를 의미 ※ 모든 이미지와 컨테이너에는 자체 내부 파일 시스템이 존재함
  - COPY . /app으로 쓸 경우 모든 파일이 app이라는 폴더에 복사되며, 폴더가 없을 경우 생성함
- `EXPOSE` : 우리의 로컬 시스템에 특정 포트를 연다고 도커에게 알려줌. 그러나 문서화하는 것 뿐이지 실제 기능적으로 동작하지 않음 => ★☆ **명시적으로 코딩을 하기 위함이지 기능적인 효력은 없음** ☆★
  - `docker run -p 3000:80 <컨테이너 명>`과 같이 작성하여 작동하게 함
    - 3000 : 로컬 포트 / 80 : 내부 도커 컨테이너 노출 포트(EXPOSE를 통해 지정한 포트)

<br>

### Dockerfile 최적화

만약 소스코드를 변경했다면, 도커 이미지 파일을 다시 빌드해야 변경했던 내용이 컨테이너에 적용이된다. 그러나 위의 dockerfile을 보면 변경한 소스코드를 복사하는 부분은 COPY이다. docker는 COPY 이전까지는 캐싱을 사용하다가 COPY해야하는 파일이 변경되었으니, 그 뒤에 오는 이미지 레이어에 대해서는 캐싱을 하지 않고 다시 처음부터 빌드하기 시작한다. 이때 npm install은 작업 시간이 많이 걸리는 일이고 지금 소스코드만 변경되었지, 실행환경에 대해 변경된 것은 없다. 다시 npm install을 할 필요가 없는데도 docker는 다시 빌드하고 있다. 

![image](https://user-images.githubusercontent.com/93081720/174915989-afb4795e-01cc-4154-a2b8-43e7a6574300.png)

`COPY package.json /app`을 npm install 위에 써줌으로써 최적화가 가능하다. node.js의 종속성을 관리하는 package.json이 변경되지 않으면 npm install을 할 필요가 없으므로 두 이미지 레이어에서 캐싱된 데이터를 사용한다. 그 후 COPY . /app에서 변경된 소스코드를 복사할 때는 변경을 감지했으므로 후속 레이어에 대해서는 캐싱을 하지않고 다시 빌드한다. => 굳이 다시 빌드할 필요 없는 npm install을 캐싱하여 사용하게 함으로써 빌드 속도를 향상 시켰다.

<br>

## 03_이미지-컨테이너 관리

### 이미지 관리

- `docker images` : 모든 이미지 리스트 출력

<br>

#### 이미지 구성 정보 확인

- `docker image inspect <이미지 ID>` : 이미지 구성 정보 등 이미지에 대해 숨겨진 모든 정보를 출력함 

<br>

#### 이미지 삭제

- `docker rmi <이미지 ID>` : 이미지 제거
  - 단, 중지된 컨테이너의 이미지만 삭제 가능(실행 중인 컨테이너의 이미지는 삭제 불가능함)
  - `docker rmi <이미지1 ID> <이미지2 ID>` : 공백(스페이스)을 구분자로 하여 여러 개 삭제 가능함
  - `-f` 옵션을 넣어서 강제로 삭제도 할 수 있음
- `docker image prune` : 사용되지 않는 모든 이미지 제거

<br>

#### 이미지 이름:태그 지정하기

> 이미지에는 Name과 Tag가 존재한다 => Name:Tag
>
> 빌드 시 -t 명령어를 붙여서 정의할 수 있다.

- 이름(Name) : 레포지토리명, 이미지 그룹을 정의 => 예) node, python
- 태그(Tag) : 그룹 내에서 특별한 이미지에 대해 정의 => 예) 14, 3.10.5, latest

=> 보통 이미지 이름과 태그는 이미지의 이름(그룹)과 버전을 붙이기 위해 사용한다.

![image](https://user-images.githubusercontent.com/93081720/175769087-3c74e7bb-d4f5-4958-8690-0ffa27aed128.png)

- `docker build -t <이미지명:태그명>`
  - 예) `docker build -t my-image:latest` : my-image라는 이름의 이미지 최신버전

※ 이미지 이름:태그를 사용함으로써 얻는 이점?

버전에 따라서 이미지의 내용물이 다르기 때문에 필요한 구성을 가진 버전의 이미지를 선택하여 가져옴으로써 더 작은 구성, 필요한 환경을 구성 가능하고 내부적으로 더 가벼운 체제를 가질 수 있기 때문

<br>

### 컨테이너 관리

#### 실행 중지된 컨테이너 '재시작'하기

`docker start <컨테이너명>`

재시작이 필요한 이유?

- docker run 명령어는 항상 새로운 컨테이너를 생성함
- 따라서 이미 생성된 컨테이너를 다시 불러와야하는 경우 docker run을 통해서 작업을 진행하는 것은 다소 부적절할 수도 있음 => 매번 굳이 컨테이너를 생성하는 것도 자원 낭비임

<br>

단, docker start를 해서 컨테이너를 재시작해도 docker run을 통해 컨테이너 생성 후 실행하는 것과는 터미널에 나오는 내용이 다름(docker run은 마치 서버를 실행한 듯하지만, docker start는 터미널 그대로임)

그러나, docker ps를 입력하면 실행 중인 컨테이너 목록에는 실행 중으로 표현됨. 실행 중인 것이 터미널 상에 표현이 되지 않을 뿐, 백그라운드에서는 실행 중임. 이는 attached 모드와 detached 모드와 관련이 있음

<br>

#### attached 모드와 detached 모드

attached(붙어 있음)와 detached(분리되어 있음)의 의미는 컨테이너가 터미널과 연결되어 있냐, 분리되어 있냐의 차이임

- attached : 실행 중인 컨테이너와 연결되어 터미널에 결과 등을 출력 가능
- detached : 실행 중인 컨테이너와 연결되어 있지 않아서 터미널 상에 입력 결과 등을 볼 수 없음

=> **docker start는 detached 모드가 default**

- `docker start -a <컨테이너 명>` : -a 옵션으로 attached 모드로 실행 가능

=> **docker run는 attached 모드가 default**

- `docker run -d <컨테이너 명>` : -d 옵션으로 detached 모드로 실행 가능

<br>

#### Interactive 모드

컨테이너의 이미지가 터미널 기반의 실행환경일 경우, 컨테이너를 재시작해도 처음 실행했을 때처럼 반응형이 아님. `-i`옵션을 섞어서 interactive 모드로 실행시켜야 우리가 원하는 대로 반응하게 할 수 있음

- `docker run -i -t <컨테이너 명>` 또는 `docker run -it <컨테이너 명>`
  - `-i` : interactive 모드로 실행함
  - `-t` : allocate pseudo TTY; 터미널로 실행함
- `docker start -a -i <컨테이너 명>` : 컨테이너를 attached 모드, interactive 모드로 재시작함

단, 터미널 기반의 실행환경을 가진 컨테이너의 경우 터미널 실행이 완료되고 나서 터미널이 종료가 되면 컨테이너도 같이 종료가 됨

<br>

#### 로그 확인(Logs)

- `docker logs <컨테이너 명>` : 해당 컨테이너의 로그를 볼 수 있음
- `docker logs -f <컨테이너 명>` : logs 기능 + 컨테이너 연결

<br>

#### 컨테이너 삭제

- `docker rm <컨테이너 명>` : 컨테이너를 삭제함
  - 실행 중인 컨테이너는 제거할 수 없으며, `docker stop <컨테이너 명>`을 통해 먼저 컨테이너를 중지한 뒤에 삭제 가능
  - `docker rm <컨테이너 1> <컨테이너 2>` : 컨테이너 이름을 공백(스페이스)를 구분자로 하여 여러 개의 컨테이너를 삭제 가능함

<br>

#### 🔔중지된 컨테이너 자동으로 제거하기

- `--rm` : 컨테이너가 종료될 때 자동으로 컨테이너를 제거함

예) `docker run -p 3000:80 -d --rm <이미지 ID>` ; 3000번 포트의 로컬호스트에 컨테이너 내부 포트 80번과 연결하고 detached 모드로 실행하며, 컨테이너가 종료될 때 자동으로 컨테이너를 제거함(`--rm`)

=> `docker stop <컨테이너 명>`을 입력하면 컨테이너가 중지됨과 동시에 삭제됨

##### ※ 언제 사용하는 것이 적절한가?

=> 재실행하는 컨테이너가 아니라 완전히 매번 새롭게 실행되어야 하는 컨테이너에 적용; 서버와 같이 바뀐 내용이 컨테이너에 적용되어야 하는 경우, 컨테이너를 중지시키고 다시 실행하는 방법은 바뀐 내용이 적용되지 않으므로 올바른 방법이 아님. 내용이 바뀌었을 경우 매번 이미지를 다시 빌드하고 새롭게 컨테이너를 생성해서 실행해야하므로 `--rm` 옵션을 통해 컨테이너를 실행하는 것이 적절함

<br>

#### 실행 중인 컨테이너로, 또는 컨테이너 밖으로 파일/폴더 복사하기

> 소스 코드를 수정했을 때, 원래라면 이미지를 다시 빌드하고 컨테이너를 생성해서 사용해야한다. 하지만 소스코드를 복사하여 컨테이너에 넣어서 사용하는 방법도 있다.(교체)
>
> 그러나 이 방법은 잘 사용하지 않는다(비권장) => 오류가 발생하기 쉽고, 파일 추적이 어려우며, 손상된 어플리케이션이 만들어질 수도 있기 때문이다. 또한 실행 중인 파일을 복사하여 교체하는 것은 불가능하기 때문에 그냥 다시 빌드하여 컨테이너를 새롭게 생성하는 방법을 사용하는 것이다.
>
> ※ 그럼에도 불구하고 사용하는 이유? => 예1) 변경하려는 웹 서버의 나머지 구성 파일이 동일한 경우, 예2) 컨테이너의 로그들을 로컬로 꺼내서 확인하고자 할 때 

##### 컨테이너로 파일/폴더 복사하기

- `docker cp <소스파일> <컨테이너 명:/컨테이너 내부 경로>`
  - 예) `docker cp dummy/. boring_dijkstra:/test` => 해당 컨테이너 내부의 test폴더 안에 로컬에 있는 dummy 폴더의 내용물을 복사해서 넣음(test폴더가 없다면 생성함)

##### 컨테이너 밖으로 파일/폴더 복사하기

- `docker cp <컨테이너명:/컨테이너 내부 경로> <소스파일을 넣을 곳>`
  - 예) `docker cp boring_dijkstra:/test dummy` => 해당 컨테이너 내부의 test폴더와 내용물을 로컬에 있는 dummy폴더로 옮김

<br>

#### 컨테이너 이름 정의하기

> 이미지나 컨테이너에 이름을 붙여서 매번 번거롭게 docker ps 명령어를 통해 리스트를 찾아볼 필요 없이 한번의 리스트 확인을 통해 이름을 정의하여 앞으로 해당 이름으로 이미지와 컨테이너를 손쉽게 사용 가능함

- `docker run --name <정의할 이름> <이미지 ID 또는 이미지명:태그>`
  - 예1) `docker run -p 3000:80 -d --rm --name my_container my_image:latest`
  - 예2) `docker stop my_container`

<br>

#### 이미지/컨테이너 공유하기

> ※ 도커의 장점 => 1. 정확하게 똑같은 개발 환경을 제공 2. 쉽게 개발 환경을 공유 셋업 가능 3. 로컬 실행 환경을 삭제 및 재설치할 필요가 없음
>
> 이미지/컨테이너 공유하기는 2번 항목과 관련 => 프로젝트 팀원에게 공유하거나 배포에 사용

☆★ 컨테이너를 공유하는 것이 아니라 이미지를 공유하는 것임 ★☆ => 이미지를 기반으로 하여 컨테이너를 생성하기 때문

##### 공유 방식

> Dockerfile != 이미지
>
> Dockerfile을 통해 빌드한 것 == 이미지

- Dockerfile을 공유
  - 공유된 Dockerfile로 docker build .을 통해 이미지를 빌드하고 컨테이너를 실행해야함
  - 따라서, Dockerfile 외에 구동을 위한 다른 주변 파일들이 필요함 
- 완성된 이미지를 공유
  - 이미지를 가져와서 실행하기만 하면끝
  - 이미 이미지에 모든 것이 다 포함되어 있기 때문에 빌드 및 다른 파일이 필요 없음

<br>

##### 공유 장소

- Docker Hub
  - 공식적인 도커 이미지 레지스트리(Official Docker Image Registry)
  - 공개(Public), 비공개(Private), **공식(Official)** 이미지들 제공
    - 공식 이미지 => 예) node.js 이미지, python 이미지 등
  - Docker Hub에서의 Repository == 이미지의 개념
- 개인 레지스트리
  - 개별 사업자 및 공급자에 의해 제공되는 이미지

<br>

#### Docker Hub에 이미지 공유(Push)하기

Docker Hub에 가입하고 로그인 한 뒤에 공개 레포지토리(Public Repository) 생성

※ 그전에 로그인이 필요하다 => `docker login`을 입력하여 터미널에서 아이디와 비밀번호를 입력하여 최초 연결을 해주면 된다.

- `docker push <docker hub 계정명/repository명:tag명>`
  - 주의1) 로컬에 있는 이미지 명:태그 명을 `docker hub 계정명/repository명:tag명` 이런 식으로 바꿔야지만 Docker Hub에 push할 수 있음 => 그냥하면 인식을 못하기 때문
  - 예) `docker push zow777/node-demo-app:latest` => docker hub에 zow777/node-demo-app이라는 이미지의 latest버전을 push함
  - 주의2) docker hub repo에 push를 위해선`docker login`을 통해 로그인 필요함
    - 로그 아웃은 `docker logout`

##### ※ 이미지 명:태그 명 재설정하기

- `docker tag <이전 이미지 명: 이전 태그 명> <새로운 이미지 명: 새로운 태그 명>`
  - 예) `docker tag node-demo:latest zow777/node-demo-app:1` => node-demo:latest라는 이미지 명과 태그 명을 가진 이미지를 zow777/node-demo-app이라는 이미지 명과 1이라는 태그 명으로 변경함

<br>

#### Docker Hub에서 이미지 가져오기(Pull)

> docker run을 통해서도 이미지를 불러오는 것이 가능하지만 차이가 있음

- `docker pull <이미지 명>`

  - 예) `docker pull zow777/node-demo-app`
  - docker pull은 항상 컨테이너 레지스트리에서 이미지의 이름에 해당하는 최신 이미지를 가져옴 

- `docker run <이미지 명>`

  - 예) `docker run zow777/node-demo-app`

  - docker run은 항상 최신 버전의 이미지를 보장하지 않음 => 로컬에서 이미지가 없다면 해당 이미지가 사용된 컨테이너의 히스토리에 접근하여 이미지를 가져옴(docker hub)

    - ##### ★ 즉, 로컬에 없을 경우 run을 하면 docker hub에서 이미지를 pull 하고 run에 대해서는 실행하지 않지만, 로컬에 이미 이미지가 있을 경우에는 run을 하면 해당 이미지가 최신인지 아닌지 상관 없이, 이미지를 실행함

<br>
