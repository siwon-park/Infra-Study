![Docker image](https://user-images.githubusercontent.com/93081720/174341063-d8894c50-7452-49b0-ae2f-7a4b019dc8a9.png)

# 01_Docker_Intro

## 1. 도커란 무엇인가?

> 도커는 컨테이너 기술로, 컨테이너를 생성하고 관리하기 위한 표준 도구이다

※ S/W에서 컨테이너란 무엇인가?

=> 표준화된 S/W 유닛

- 컨테이너 => 물건을 옮기는데 도움을 주는 도구; 표준화된 컨테이너가 있으면 그 곳에 있는 물건 들은 다른 곳과 섞이지 않음 해당 컨테이너만 옮기면 안의 물건들은 어디든 갈 수 있음

- 피크닉 바구니 => 접시, 음식이 담겨 있고, 친구와 피크닉 바구니를 공유 가능하고 어디에서든 안에 있는 내용물을 들고 이동해서 피크닉을 즐길 수 있음

<br>

### 컨테이너가 필요한 이유?

- 왜 컨테이너가 필요한가?
- 독립적인 표준화된 어플리케이션 패키지를 제공하는 이유?

#### 개발 환경 때문

동일한 개발 환경을 갖는다는 것은 굉장히 중요함. 어떤 곳에서는 해당 버전에 맞는 런타임 환경이 구축되어 있어서 바로 실행이 가능한 반면, 어떤 곳은 그렇지 못한 곳이 있음

- 큰 팀에는 동일한 프로젝트를 하지만 각 개개인의 개발 환경이 충분히 다를 수도 있음 => 만약 어떤 팀원이 프로그램 버전 업데이트를 한동안 안했다면 해당 팀원의 환경에서는 프로젝트가 구동되지 않을 수도 있음

- 혼자 작업하는 경우에도 유용; 작업하는 프로젝트가 여러 개일 경우 프로젝트의 사용 프로그램 버전 차이로 인해서 프로젝트 간 충돌 발생 가능성이 있음
  => 도커와 컨테이너의 개념을 적용하면 프로젝트 간 전환이 매우 쉬워짐. 각 환경(프로그램 버전 등)을 컨테이너별로 보관하고 각 프로젝트를 해당 컨테이너가 제공해주는 공간을 사용하게 함(각 프로젝트별로 개별 컨테이너를 가지게 함)

<br>

**컨테이너 안에 담긴 것들을 어디에서나 실행해도 항상 동일한 동작을 보장한다**

**도커 컨테이너를 사용한다면 코드가 항상 정확한 버전으로 실행되도록 할 수 있음**

**같은 코드 기반에서 함께 작업 가능, 항상 작동, 항상 같은 환경을 제공**

<br>

### 가상 머신 VS 컨테이너

#### 의문점

"도커가 제공하는 기능을 가상 머신으로 해결하면 되는 거 아닌가??" => "Maybe"

<br>

#### 가상 머신(Virtual Machine)

가상 머신을 통해서 독립된 공간을 만들고 생산 가능함, 재생산 및 공유 가능

VM은 OS위에 설치하는 것임 따라서 해당 VM 안에 설치한 OS에 맞는 VM OS가 존재함

![image-20220618011746660](https://user-images.githubusercontent.com/93081720/175768347-38842d09-6d47-4cc6-970c-e41378ffa559.png)

그러나 이는 문제가 있음. 어찌 됐든 VM은 OS 위에 설치되어있고 그 수가 다수라면 우리 OS의 자원(메모리, CPU)과 저장공간 등을 낭비하게 됨 => 점점 많아지면 많아질수록 OS의 오버헤드가 발생할 수 밖에 없음

또한, 매번 VM을 설치할 때마다 설정을 해줘야하며, 해당 설정을 직접 해야하기 때문에 100% 동일한 VM 환경이라고 볼 수 없음

개발에서 제품 생산으로 어플리케이션을 배포하려면 해당 프로젝트를 작업했던 VM 환경과 동일한 방식, 환경의 프로덕션 머신을 구성해야한다는 단점 존재

<br>

#### 컨테이너(Container)

하나의 OS 위에 해당 OS가 기본적으로 내재하고 있거나 컨테이너 에뮬레이터를 지원하는 내장 컨테이너를 사용하여 도커 엔진이 컨테이너를 구축함

![image-20220618012654144](https://user-images.githubusercontent.com/93081720/175768353-39f494b6-2469-42d6-9921-5643c268d2b2.png)

컨테이너는 VM과 달리 OS에 미치는 영향이 적고, 속도도 빠르고, 용량이 작음, 공유 가능(배포 및 재구축이 쉬움), 앱과 앱의 실행에 필요한 것들만 캡슐화할 수 있음

반면, VM은 OS에 많은 영향을 끼치고, 상대적으로 느리고, 많은 공간을 차지함, 공유/재구축이 컨테이너에 비해 힘듦. 환경을 캡슐화하긴 하지만 앱과 앱 실행에 필요한 것들 뿐만 아니라 컴퓨터 전체를 캡슐화하는 개념임

=> 컨테이너의 최대 장점은 동일한 환경을 다른 사람과 공유 가능하다는 점

<br>

#### ※ 도커 설치

리눅스는 도커 엔진을 기본적으로 지원함. 따라서 사실상 별도로 설치할 필요가 없음

그러나 윈도우나, MacOS의 경우 Docker Desktop을 설치해야 Docker를 사용 가능함

WSL2는 윈도우 내부에 리눅스를 설치하는 개념이라고 이해하는 것이 편함

<br>

## 2. 도커 기본 명령어

### 도커 기본 명령어

- `docker build .` : 현재 도커 파일 내용을 토대로 이미지를 빌드함
- `docker run <이미지 ID>` : 빌드한 이미지를 연결/실행함 => 실행하면 마치 서버가 켜진 상태라고 보는 것이 편함
  - `docker run -p 3000:80 <이미지 ID>` : 이미지를  3000번 포트에 publish하여 실행함
    - 3000 : 로컬 포트 / 80 : 내부 도커 컨테이너 노출 포트(EXPOSE를 통해 지정한 포트)
- `docker ps` : 현재 실행 중인 컨테이너 리스트를 출력함 ※ 이미지를 실행 중이라면 새로운 터미널에서 입력
  - `docker ps -a` : ps는 프로세스, -a는 all의 의미

- `docker stop <컨테이너 이름>` : 컨테이너를 중지함 ※ 시간이 조금 걸릴 수도 있음
- `docker run -it <이미지/런타임 명>` : 예) docker run -it node => 컨테이너 내부에서 node.js 환경을 실행

<br>

### RUN, CMD, ENTRYPOINT 명령어 간 차이점

세 명령어 모두 '실행'과 연관된 명령어이나 차이가 있기 때문에 사용에 유의해야할 부분이 있다.

#### RUN

> 이미지를 빌드하는 시점에 실행되는 명령어

보통 컨테이너 실행 환경을 구축하기 위해 필요한 dependencies나 라이브러리들을 설치하기 위해 사용됨



#### CMD

> 컨테이너 실행 시 수행되는 명령어

Dockerfile에 한번만 등장해야 하는 명령어로, 컨테이너를 실행하면서 수행되어야하는 명령어를 지정하여 수행하게 한다.

단, ENTRYPOINT와 차이가 있다면, CMD 명령어는 default 수행 명령어가 아니기 때문에, docker run 명령어 작성 시 다른 수행 명령어를 입력한다면 오버라이딩 되어 오버라이딩 된 명령어가 수행된다.



#### ENTRYPOINT

> 컨테이너 실행 시 수행되는 명령어

컨테이너를 실행하면서 수행되어야하는 명령어를 지정하여 수행하게 한다.

단, CMD와 차이가 있다면, ENTRYPOINT는 default 명령어로써 항상 수행된다. 그래서 보통 컨테이너 실행 후 변경되지 않을 명령어를 지정하여 사용한다.

<br>

### COPY와 ADD 명령어의 차이점

두 명령어 모두 '복사'와 관련되어 있지만 명백한 차이가 있어 사용에 유의해야 할 부분이 있다.

일단, 공식 문서 상에서는 두 명령어 모두 일반적인 기능면에서는 동일하나, `COPY`가 `ADD`보다 더 투명하기 때문에 선호된다고 나와있다.

#### COPY

> Host 환경의 파일 또는 디렉토리를 대상 컨테이너 이미지 안으로 복사하는 명령어

단순히 로컬 파일 또는 디렉토리를 도커 이미지로 '복사'한다

실행에 필요한 환경 설정 파일이나 구성 파일 등 그냥 말 그대로 복사만 해도 괜찮은 파일일 경우 COPY 명령어를 쓰는 것이 적절하다.

##### ※ 주의점

다음과 같이 복사하려는 대상(들)을 지칭할 때 `*(아스테릭)`을 사용할 경우, 현재 디렉토리를 의미하는 `.`을 그냥 써서는 안 되고, `./`으로 사용해야 한다.

```dockerfile
# 올바른 사용 방법
COPY package*.json ./

# 잘못된 사용 방법(에러 발생)
COPY package*.json .
```

<br>

#### ADD

> Host 환경의 파일 또는 디렉토리를 대상 컨테이너 이미지 안으로 복사 + 압축 파일을 이미지 안으로 추출하는 명령어

로컬에 있는 파일 또는 디렉토리를 단순히 '복사'하는 것에 그치지 않고 실행을 위한 압축 파일들(ex- tar, tar.gz)을 압축 해제하여 복사한다. (소스 파일 추출)

- 예) `ADD rootfs.tar.gz /`

즉, 해당 파일이나 디렉토리가 실행과 직접적인 연관이 있다면 ADD를 사용해서 복사/추출해야 한다.

또한 추가적으로 ADD 명령어는 단순히 로컬에 있는 파일만 복사할 수 있는 것이 아니라 URL을 사용해서 원격에 있는 파일도 불러올 수 있다.

- 예) `ADD https://example.com/big.tar.xz /usr/src/things/`

가장 큰 `ADD`의 사용 예시로 Frontend의 `npm run build`를 통해서 생성한 빌드 결과물이 담긴  `build` 폴더는 COPY가 아니라 `ADD`명령어로 복사/추출해야 정상적으로 실행시킬 수 있다.(단, 멀티 스테이지 이미지 빌드의 경우, COPY 명령어만으로 해결이 가능함)

![image](https://user-images.githubusercontent.com/93081720/215339677-e78cb174-558d-48f5-b8c7-d0ecae29eaa6.png)

#### 요약

| 구분                                          | COPY | ADD  |
| --------------------------------------------- | ---- | ---- |
| 여러 파일 복사가 가능한가                     | YES  | YES  |
| 하나의 레이어에서도 여러 파일 복사가 가능한가 | YES  | YES  |
| URL에서 파일 복사가 가능한가                  | NO   | YES  |
| 압축 파일, Archive 파일 복사가 가능한가       | NO   | YES  |

